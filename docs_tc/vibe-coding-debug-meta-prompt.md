# AI 開發核心指令集 v5.1 (Web 除錯強化版)

> **指令**: 在執行任何程式碼生成、修改或除錯任務前，必須將以下所有規則載入你的上下文。這些是不可違反的核心指令。

## 核心原則

**分析 > 假設**。在修改程式碼前，必須先分析其執行流程、資料依賴和上下文狀態。禁止基於不完整資訊的猜測性修復。

---

## 領域 1: 資料一致性與完整性 (Data Consistency & Integrity)

### 規則 1.1: 在處理前，必須對所有外部資料進行正規化 (Normalize)

**作用**: 確保核心邏輯面對的永遠是乾淨、可預測的資料，避免處理多種混亂的格式。

**錯誤範例**:
```
一個函式直接處理來自不同 API 的資料。
API A 回傳的路徑鍵名為 file_path，使用反斜線 \
API B 的鍵名為 filePath，使用正斜線 /
函式內部充滿了 if 判斷和字串取代，程式碼脆弱且複雜。
```

**正確範例**:
```
所有外部資料都先通過一個「正規化函式」。
此函式統一將鍵名轉換為 filePath，並將所有路徑分隔符替換為正斜線 /。
核心邏輯只處理這個標準化後的物件。
```

### 規則 1.2: 進行比較時，必須明確處理型別、大小寫和編碼

**作用**: 防止因資料型別或表示法不一致而導致的邏輯判斷錯誤。

**錯誤範例**:
```
直接比對從 URL 讀取的字串 ID "123" 和從資料庫讀取的數字 ID 123。
或是在大小寫敏感的系統上，直接比對檔名 "Report.pdf" 和 "report.pdf"，
導致找不到檔案。
```

**正確範例**:
```
在比較前進行顯式轉換。將字串 ID 明確轉為數字後再進行嚴格比較。
對於檔名，先將兩者都轉換為小寫再進行比對，確保結果與平台無關。
```

### 規則 1.3: 必須釐清語義模糊的欄位

**作用**: 避免因欄位名稱相似但實際含義不同，而造成的邏輯混亂。

**錯誤範例**:
```
系統中有 lastUpdated 和 modifiedTime 兩個時間欄位。
開發時假設它們意義相同，隨意取用。
但實際上前者指「記錄被同步的時間」，後者指「原始資料的修改時間」，
導致時間相關的功能完全錯亂。
```

**正確範例**:
```
在開發前建立或參考「資料字典」，明確每個欄位的確切含義。
在程式碼註解或變數命名中反映這種差異，
例如 syncTimestamp 和 contentModificationTimestamp。
```

---

## 領域 2: 非同步操作與時序 (Asynchronous Operations & Timing)

### 規則 2.1: 嚴禁假設非同步操作會立即完成

**作用**: 確保在使用非同步操作的結果之前，該操作已經執行完畢，避免競爭條件。

**錯誤範例**:
```
第一行發起網路請求獲取資料，
第二行就立刻嘗試使用預期會返回的資料。
這必然會出錯，因為網路請求需要時間，此時資料變數仍是空的。
```

**正確範例**:
```
所有依賴非同步結果的程式碼，都必須放在能確保「等待」的機制中，
例如 Promise 的 .then() 區塊，或是使用 async/await 語法。
```

### 規則 2.2: 初始化與事件綁定必須是冪等 (Idempotent) 的

**作用**: 防止因元件重複渲染而導致的事件重複綁定，從而避免效能問題和邏輯錯誤。

**錯誤範例**:
```
每次渲染一個元件，都會為其中的按鈕綁定一次點擊事件。
渲染三次後，使用者點擊一次按鈕，事件卻觸發了三次。
```

**正確範例**:
```
在綁定事件前先檢查一個旗標，確保只綁定一次。
或者，在元件的生命週期管理中，於「創建」時綁定，
並於「銷毀」時明確地移除該事件。
```

### 規則 2.3: 必須明確管理非同步操作的依賴順序

**作用**: 當多個非同步操作有先後順序時，確保它們按正確的順序執行。

**錯誤範例**:
```
系統需要先載入「設定檔」，再根據設定檔中的資訊去請求「使用者資料」。
但兩個請求被同時發起，導致請求使用者資料時因缺少必要的設定資訊而失敗。
```

**正確範例**:
```
使用 await 確保第一個非同步操作（載入設定檔）完成後，
再執行第二個非同步操作（請求使用者資料）。
如果操作之間無依賴，則可使用 Promise.all 讓它們並行以提升效率。
```

---

## 領域 3: UI 元素管理與互動 (UI Element Management & Interaction)

### 規則 3.1: 必須對動態產生的元素使用事件委派 (Event Delegation)

**作用**: 確保事件能被綁定到那些在初始頁面載入後才被新增到畫面上的元素。

**錯誤範例**:
```
頁面載入時，腳本為所有 class="list-item" 的元素綁定事件。
但這些項目是稍後才由另一個網路請求非同步載入的，導致事件綁定失敗。
```

**正確範例**:
```
將事件綁定到它們穩定存在的父容器上。
當點擊發生時，檢查事件來源是否是目標項目，
這樣無論項目何時被新增進來，都能被正確處理。
```

### 規則 3.2: 必須維持單一資料來源 (Single Source of Truth) 來驅動 UI

**作用**: 保證當同一份資料在 UI 多處顯示時，所有顯示都保持一致。

**錯誤範例**:
```
當資料總數變更時，程式碼只記得更新頁面標題中的數字，
卻忘記更新側邊欄的數字，導致 UI 顯示不一致。
```

**正確範例**:
```
系統中存在一個中央「狀態」，UI 的所有部分都從這個狀態讀取資料。
任何操作都只修改這個中央狀態，然後觸發一個統一的更新機制，
讓所有相關的 UI 部分自動刷新。
```

### 規則 3.3: 嚴禁在不同視圖或元件中使用重複的 ID

**作用**: id 在 HTML 中必須是全域唯一的，重複會導致元素選擇器和事件處理邏輯定位到錯誤的元素。

**錯誤範例**:
```
「總覽」頁面和「詳細設定」頁面中，都有一個 id="save-button" 的按鈕。
當程式碼試圖操作這個按鈕時，可能會因為頁面結構的細微差異而選取到
非預期的按鈕，引發隱蔽的 Bug。
```

**正確範例**:
```
確保 id 的唯一性，或優先使用 class 進行元素選取。
對於可重用元件，可以使用 data-* 屬性或在 id 中加入
唯一的識別符來區分實例。
```

---

## 領域 4: 字串與模式匹配 (String & Pattern Matching)

### 規則 4.1: 優先使用簡單的字串方法，而非複雜的正則表達式

**作用**: 提升程式碼的可讀性和可維護性，降低出錯機率。

**錯誤範例**:
```
為了從一個檔案路徑 a/b/c.txt 中取得檔名 c.txt，寫了一個複雜的正則表達式。
這個正則難以理解，且在面對如 a/b.c/d.txt 等邊界情況時容易出錯。
```

**正確範例**:
```
使用內建的、簡單的字串操作。
例如，先用 / 分割字串，然後取最後一個元素。
這個方法意圖清晰，且更加健壯。
```

### 規則 4.2: 必須使用標準函式庫處理路徑、URL 等標準格式

**作用**: 避免自己處理跨平台、編碼等複雜細節，交給經過充分測試的標準庫來完成。

**錯誤範例**:
```
手動用 + 號和斜線 / 來拼接檔案路徑。
這種作法在 Windows 和 Linux 系統之間切換時會因為路徑分隔符不同而失效。
```

**正確範例**:
```
引入並使用專門的路徑處理函式庫（例如 Node.js 的 path.join），
它會自動根據當前的作業系統使用正確的分隔符。
```

---

## 領域 5: 錯誤處理與日誌記錄 (Error Handling & Logging)

### 規則 5.1: 嚴禁忽略或「吞噬」錯誤

**作用**: 確保所有異常情況都被記錄和處理，避免靜默失敗，讓除錯成為可能。

**錯誤範例**:
```
在一個 try...catch 結構中，catch 區塊是空的。
當錯誤發生時，程式不會崩潰，但會以一種不正常的狀態繼續運行，
導致後續出現更難以追蹤的問題。
```

**正確範例**:
```
catch 區塊至少要將錯誤資訊完整地記錄到日誌中。
理想情況下，應根據錯誤類型採取相應的恢復措施，
或向使用者顯示友善的提示。
```

### 規則 5.2: 錯誤日誌必須包含充足的上下文

**作用**: 提供足夠的資訊，以便開發者能快速定位並重現問題。

**錯誤範例**:
```
日誌只記錄了「檔案讀取失敗」。
開發者不知道是哪個檔案、在哪個操作中、因為什麼原因失敗。
```

**正確範例**:
```
日誌記錄為：
「[Error] 函式 processUserData 中讀取設定檔 /etc/app/config.json 失敗。
原因：JSON 解析錯誤於第 15 行。」
```

---

## 領域 6: 效能與資源管理 (Performance & Resource Management)

### 規則 6.1: 避免在迴圈中進行高成本操作

**作用**: 防止因重複執行昂貴操作（如 DOM 修改、檔案寫入、網路請求）而導致的效能瓶頸。

**錯誤範例**:
```
在一個迴圈中，每次都向頁面新增一個 DOM 元素，
迴圈 1000 次導致頁面重繪 1000 次，造成畫面卡頓。
```

**正確範例**:
```
在迴圈中，先將所有要新增的元素放入一個記憶體中的「文件片段」，
迴圈結束後，一次性地將這個片段插入頁面，只引發一次重繪。
```

### 規則 6.2: 必須快取高成本運算的結果 (Memoization)

**作用**: 對於輸入相同、輸出也相同的耗時計算，避免重複執行以提升效能。

**錯誤範例**:
```
一個函式需要對一個大型陣列進行複雜的統計計算。
在 UI 每次重新渲染時，即使陣列內容沒有改變，
這個耗時的函式也被反覆完整地執行一次。
```

**正確範例**:
```
將計算結果與其輸入一起儲存起來。
下次使用相同輸入呼叫函式時，直接回傳儲存的結果，而不是重新計算。
```

### 規則 6.3: 必須清理不再需要的監聽器、計時器等副作用

**作用**: 防止記憶體洩漏，確保應用程式長時間運行的穩定性。

**錯誤範例**:
```
一個元件在創建時設定了一個每秒執行的計時器 (setInterval)。
當這個元件被銷毀、從畫面上移除時，沒有清除這個計時器。
導致計時器在背景中永遠運行，持續消耗資源。
```

**正確範例**:
```
在元件的生命週期管理中，於「創建」時設定計時器，
並在其「銷毀」階段，明確地呼叫 clearInterval 來停止它。
```

---

## 領域 7: 系統互動與檔案管理 (System Interaction & File Management)

### 規則 7.1: 必須嚴格管理臨時檔案的生命週期

**作用**: 保持專案目錄的整潔，避免混淆，防止遺留不必要的檔案。

**錯誤範例**:
```
為了測試，程式在專案根目錄下直接建立 test.json。
測試結束後，檔案被遺留下來。
多次操作後，目錄下充滿了各種無法判斷用途的臨時檔案。
```

**正確範例**:
```
臨時檔案必須以 temp_ 等前綴命名，並優先產生在系統臨時目錄下。
最重要的是，使用 try...finally 結構，確保在操作完成或失敗後，
finally 區塊中的檔案刪除邏輯一定會被執行。
```

---

## 領域 8: 開發流程與驗證 (Development Process & Validation)

### 規則 8.1: 必須主動驗證假設，而不是盲目信任

**作用**: 在錯誤發生前就捕捉到它，提升程式碼的健壯性。

**錯誤範例**:
```
一個函式接收一個參數 items，程式碼直接假設它是一個陣列，
並呼叫 items.map()。
當傳入的 items 是 null 或 undefined 時，程式立刻崩潰。
```

**正確範例**:
```
在呼叫 .map() 之前，先檢查 items 是否為真且是否為陣列。
如果不是，則提前返回一個空陣列或進行錯誤處理。
```

### 規則 8.2: 必須考慮並測試邊界情況

**作用**: 確保程式碼在處理非典型、極端或錯誤的輸入時也能正常運作。

**錯誤範例**:
```
開發一個列表排序功能時，只用了包含 5 個正常項目的陣列來測試。
沒有測試過空陣列、只包含一個項目的陣列、或包含 null 值的陣列。
```

**正確範例**:
```
在開發和測試時，主動使用各種邊界情況作為輸入：
- 空值 (null, undefined)
- 空集合（空字串、空陣列）
- 單元集合
- 包含異常格式或極端值的集合
```

### 規則 8.3: 針對 Web 應用除錯，必須使用自動化瀏覽器控制進行，並主動報告結果

**作用**: 自動化地重現前端 Bug、捕捉執行期錯誤，並提供具體的診斷報告，從而取代「要求使用者手動查看 console」的低效率做法。

**錯誤範例**:
```
當被告知「網站上的某個按鈕點了沒反應」時，AI 回覆：
「程式碼邏輯看起來沒問題，請你打開瀏覽器的開發者工具，
點擊按鈕後看看 Console 標籤頁裡有沒有報錯，然後告訴我錯誤訊息。」
—— 這種做法將除錯的責任推回給了使用者。
```

**正確範例**:
```
當收到前端 Bug 回報時，AI 應主動採取以下自動化流程：

1. 啟動工具: 
   表明將使用 Puppeteer 或類似的無頭瀏覽器工具來模擬使用者操作。

2. 設定環境: 
   在腳本中設定監聽器來捕捉：
   - console 事件（包括 console.log、console.error 等訊息）
   - pageerror 事件（未被捕獲的 JavaScript 執行期錯誤）
   - requestfailed 事件（所有失敗的網路請求，如 404 或 CORS 錯誤）

3. 模擬操作: 
   程式化地導航到指定頁面，並執行觸發 Bug 的操作（例如，點擊按鈕、填寫表單）。

4. 分析與報告: 
   收集所有監聽到的錯誤和日誌，然後整理成一份清晰的報告，直接呈現給使用者。
   
   報告應包含：
   - 操作步驟
   - 捕獲到的錯誤訊息
   - 錯誤發生的原始碼位置
   - 初步的原因分析
   
   例如：
   「自動化除錯報告：
   在點擊 #login-button 後，捕捉到 pageerror 事件，
   錯誤為 TypeError: Cannot read properties of undefined (reading 'value')，
   發生於 login.js 的第 52 行。
   初步分析為登入腳本試圖讀取一個不存在的 DOM 元素的值。」
```

---

## 總結

這些規則構成了 AI 輔助開發的核心防護網。遵循這些規則，可以顯著減少常見錯誤，提高程式碼品質，並加快開發速度。記住：**分析先於假設，驗證重於信任**。