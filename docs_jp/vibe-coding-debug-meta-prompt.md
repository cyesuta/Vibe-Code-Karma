# AI開発コア命令セット v5.1 (Webデバッグ強化版)

> **指令**: コードの生成、修正、またはデバッグタスクを実行する前に、以下のすべてのルールをコンテキストにロードする必要があります。これらは違反不可能なコア指令です。

## コア原則

**分析 > 仮説**。コードを修正する前に、まずその実行フロー、データ依存関係、およびコンテキストの状態を分析しなければなりません。不完全な情報に基づく推測的な修正は禁止です。

---

## 領域1: データの一貫性と完全性 (Data Consistency & Integrity)

### ルール 1.1: 処理の前に、すべての外部データを正規化 (Normalize) しなければならない。

**目的**: コアロジックが常にクリーンで予測可能なデータを扱うようにし、複数の混沌としたフォーマットを処理する必要を避けるため。

**誤った例**:
```
ある関数が、異なるAPIからのデータを直接処理する。
API Aはパスのキー名として `file_path` を返し、バックスラッシュ `\` を使用する。
API Bのキー名は `filePath` で、スラッシュ `/` を使用する。
関数の内部は `if` 判断と文字列置換で満ており、コードは脆弱で複雑になる。
```

**正しい例**:
```
すべての外部データは、まず「正規化関数」を通過する。
この関数はキー名を `filePath` に統一し、すべてのパス区切り文字をスラッシュ `/` に置換する。
コアロジックはこの標準化されたオブジェクトのみを処理する。
```

### ルール 1.2: 比較を行う際は、型、大文字/小文字、エンコーディングを明確に処理しなければならない。

**目的**: データ型や表現の不一致による論理判断のエラーを防ぐため。

**誤った例**:
```
URLから読み取った文字列ID "123" と、データベースから読み取った数値ID 123 を直接比較する。
あるいは、大文字/小文字を区別するシステムで、ファイル名 "Report.pdf" と "report.pdf" を直接比較し、
ファイルが見つからない結果になる。
```

**正しい例**:
```
比較の前に明示的な変換を行う。文字列IDを明確に数値に変換してから厳密な比較を行う。
ファイル名については、両方を小文字に変換してから比較し、結果がプラットフォームに依存しないようにする。
```

### ルール 1.3: 意味が曖昧なフィールドを明確にしなければならない。

**目的**: フィールド名が似ているが実際の意味が異なることによる論理の混乱を避けるため。

**誤った例**:
```
システムには `lastUpdated` と `modifiedTime` という2つの時間フィールドがある。
開発時、それらの意味が同じだと仮定し、任意に使用する。
しかし実際には、前者は「レコードが同期された時間」を指し、後者は「元データの修正時間」を指すため、
時間関連の機能が完全に混乱する。
```

**正しい例**:
```
開発の前に「データ辞書」を作成または参照し、各フィールドの正確な意味を明確にする。
コードのコメントや変数名にその違いを反映させる。
例: `syncTimestamp` と `contentModificationTimestamp`。
```

---

## 領域2: 非同期操作とタイミング (Asynchronous Operations & Timing)

### ルール 2.1: 非同期操作が即座に完了すると仮定してはならない。

**目的**: 非同期操作の結果を使用する前に、その操作が完了していることを保証し、競合状態を避けるため。

**誤った例**:
```
1行目でデータを取得するためのネットワークリクエストを開始し、
2行目でそのリクエストから返されるはずのデータをすぐに使用しようとする。
ネットワークリクエストには時間がかかるため、この時点でデータ変数はまだ空であり、これは必ずエラーになる。
```

**正しい例**:
```
非同期の結果に依存するすべてのコードは、「待機」を保証するメカニズムの中に配置しなければならない。
例えば、Promiseの `.then()` ブロックや、`async/await` 構文を使用する。
```

### ルール 2.2: 初期化とイベントバインディングは冪等（Idempotent）でなければならない。

**目的**: コンポーネントの再レンダリングによるイベントの重複バインディングを防ぎ、パフォーマンスの問題と論理エラーを回避するため。

**誤った例**:
```
コンポーネントがレンダリングされるたびに、その中のボタンにクリックイベントをバインドする。
3回レンダリングされた後、ユーザーがボタンを1回クリックすると、イベントが3回トリガーされる。
```

**正しい例**:
```
イベントをバインドする前にフラグをチェックし、一度だけバインドされるようにする。
あるいは、コンポーネントのライフサイクル管理において、「作成時」にバインドし、
「破棄時」にそのイベントを明示的に削除する。
```

### ルール 2.3: 非同期操作の依存順序を明確に管理しなければならない。

**目的**: 複数の非同期操作に前後関係がある場合、それらが正しい順序で実行されることを保証するため。

**誤った例**:
```
システムはまず「設定ファイル」をロードし、次にその設定ファイルの情報に基づいて「ユーザーデータ」をリクエストする必要がある。
しかし、2つのリクエストが同時に開始され、ユーザーデータのリクエストが必要な設定情報なしで失敗する。
```

**正しい例**:
```
`await` を使用して、最初の非同期操作（設定ファイルのロード）が完了した後に、
2番目の非同期操作（ユーザーデータのリクエスト）を実行するようにする。
操作間に依存関係がない場合は、`Promise.all` を使用して並列実行し、効率を向上させることができる。
```

---

## 領域3: UI要素の管理とインタラクション (UI Element Management & Interaction)

### ルール 3.1: 動的に生成される要素にはイベント委任 (Event Delegation) を使用しなければならない。

**目的**: 初期のページロード後に追加された要素にもイベントがバインドされるようにするため。

**誤った例**:
```
ページロード時に、スクリプトが `class="list-item"` を持つすべての要素にイベントをバインドする。
しかし、これらのアイテムは後から別のネットワークリクエストによって非同期にロードされるため、イベントのバインドに失敗する。
```

**正しい例**:
```
イベントを、安定して存在する親コンテナにバインドする。
クリックが発生した際に、イベントの発生源がターゲットアイテムであるかを確認する。
これにより、アイテムがいつ追加されても正しく処理される。
```

### ルール 3.2: UIを駆動するためには単一のデータソース (Single Source of Truth) を維持しなければならない。

**目的**: 同じデータがUIの複数箇所に表示される場合、すべての表示が一貫していることを保証するため。

**誤った例**:
```
データ総数が変更されたとき、コードはページタイトル内の数字を更新することだけを覚えており、
サイドバーの数字を更新し忘れるため、UIの表示が不一致になる。
```

**正しい例**:
```
システム内に中央の「状態（state）」が存在し、UIのすべての部分がこの状態からデータを読み取る。
いかなる操作もこの中央の状態のみを変更し、その後、統一された更新メカニズムをトリガーして、
関連するすべてのUI部分が自動的にリフレッシュされるようにする。
```

### ルール 3.3: 異なるビューやコンポーネントで重複したIDを使用してはならない。

**目的**: `id` はHTML内でグローバルに一意でなければならず、重複すると要素セレクタやイベント処理ロジックが誤った要素を対象としてしまうため。

**誤った例**:
```
「概要」ページと「詳細設定」ページの両方に、`id="save-button"` を持つボタンがある。
コードがこのボタンを操作しようとすると、ページの構造の微妙な違いにより、
予期しないボタンが選択され、隠れたバグを引き起こす可能性がある。
```

**正しい例**:
```
`id` の一意性を保証するか、要素の選択には `class` を優先的に使用する。
再利用可能なコンポーネントについては、`data-*` 属性を使用するか、`id` に
一意の識別子を追加してインスタンスを区別する。
```

---

## 領域4: 文字列とパターンマッチング (String & Pattern Matching)

### ルール 4.1: 複雑な正規表現ではなく、単純な文字列メソッドを優先して使用する。

**目的**: コードの可読性と保守性を向上させ、エラーの可能性を低減するため。

**誤った例**:
```
ファイルパス `a/b/c.txt` からファイル名 `c.txt` を取得するために、複雑な正規表現を作成する。
この正規表現は理解が難しく、`a/b.c/d.txt` のようなエッジケースでエラーが発生しやすい。
```

**正しい例**:
```
組み込みの単純な文字列操作を使用する。
例えば、まず `/` で文字列を分割し、最後の要素を取得する。
この方法は意図が明確で、より堅牢である。
```

### ルール 4.2: パスやURLなどの標準フォーマットの処理には、標準ライブラリを使用しなければならない。

**目的**: クロスプラットフォームやエンコーディングなどの複雑な詳細を自分で処理するのを避け、十分にテストされた標準ライブラリに任せるため。

**誤った例**:
```
`+` 記号とスラッシュ `/` を使って手動でファイルパスを連結する。
この方法は、WindowsとLinuxシステム間で切り替える際に、パス区切り文字が異なるため失敗する。
```

**正しい例**:
```
専用のパス処理ライブラリ（例: Node.jsの `path.join`）をインポートして使用する。
これにより、現在のオペレーティングシステムに応じて自動的に正しい区切り文字が使用される。
```

---

## 領域5: エラーハンドリングとロギング (Error Handling & Logging)

### ルール 5.1: エラーを無視したり、「飲み込んだり」してはならない。

**目的**: すべての例外的な状況が記録・処理されることを保証し、サイレントフェイラーを避け、デバッグを可能にするため。

**誤った例**:
```
`try...catch` 構造で、`catch` ブロックが空になっている。
エラーが発生してもプログラムはクラッシュしないが、異常な状態で実行を継続し、
後で追跡がより困難な問題を引き起こす。
```

**正しい例**:
```
`catch` ブロックは、少なくともエラー情報を完全にログに記録しなければならない。
理想的には、エラーの種類に応じて適切な回復措置を講じるか、
ユーザーに分かりやすいヒントを表示すべきである。
```

### ルール 5.2: エラーログには十分なコンテキストを含めなければならない。

**目的**: 開発者が問題を迅速に特定し、再現できるだけの十分な情報を提供するため。

**誤った例**:
```
ログには「ファイル読み込み失敗」としか記録されていない。
開発者は、どのファイルが、どの操作で、何が原因で失敗したのかがわからない。
```

**正しい例**:
```
ログ記録は次のようになる：
「[Error] 関数 processUserData で設定ファイル /etc/app/config.json の読み込みに失敗しました。
原因：15行目でJSON解析エラー。」
```

---

## 領域6: パフォーマンスとリソース管理 (Performance & Resource Management)

### ルール 6.1: ループ内で高コストな操作を避ける。

**目的**: 高価な操作（DOM操作、ファイル書き込み、ネットワークリクエストなど）の繰り返し実行によるパフォーマンスのボトルネックを防ぐため。

**誤った例**:
```
ループ内で、毎回ページにDOM要素を追加する。
1000回ループすると、ページが1000回再描画され、画面が固まる原因となる。
```

**正しい例**:
```
ループ内では、まず追加するすべての要素をメモリ内の「ドキュメントフラグメント」に入れる。
ループが終了した後、このフラグメントを一度にページに挿入し、再描画を一度だけ引き起こす。
```

### ルール 6.2: 高コストな計算結果はキャッシュしなければならない (メモ化)。

**目的**: 同じ入力に対して同じ出力を生成する時間のかかる計算について、再実行を避けてパフォーマンスを向上させるため。

**誤った例**:
```
ある関数が、大きな配列に対して複雑な統計計算を行う必要がある。
UIが再レンダリングされるたびに、配列の内容が変わっていなくても、
この時間のかかる関数が何度も完全に実行される。
```

**正しい例**:
```
計算結果を入力と共に保存しておく。
次回、同じ入力で関数が呼び出されたときは、再計算するのではなく、保存された結果を直接返す。
```

### ルール 6.3: 不要になったリスナーやタイマーなどの副作用はクリーンアップしなければならない。

**目的**: メモリリークを防ぎ、アプリケーションの長期間の安定した動作を保証するため。

**誤った例**:
```
あるコンポーネントが作成される際に、毎秒実行されるタイマー (`setInterval`) を設定する。
このコンポーネントが破棄され、画面から削除されるときに、このタイマーをクリアしない。
これにより、タイマーがバックグラウンドで永遠に実行され続け、リソースを消費し続ける。
```

**正しい例**:
```
コンポーネントのライフサイクル管理において、「作成時」にタイマーを設定し、
その「破棄」段階で、`clearInterval` を明示的に呼び出して停止させる。
```

---

## 領域7: システムインタラクションとファイル管理 (System Interaction & File Management)

### ルール 7.1: 一時ファイルのライフサイクルを厳格に管理しなければならない。

**目的**: プロジェクトディレクトリを清潔に保ち、混乱を避け、不要なファイルが残るのを防ぐため。

**誤った例**:
```
テストのために、プログラムがプロジェクトのルートディレクトリに直接 `test.json` を作成する。
テスト終了後、ファイルはそのまま残される。
何度も操作を繰り返すと、ディレクトリは用途不明な一時ファイルで溢れかえる。
```

**正しい例**:
```
一時ファイルには `temp_` などのプレフィックスを付け、できればシステムの一次ディレクトリに生成する。
最も重要なのは、`try...finally` 構造を使用し、操作が成功または失敗した後に、
`finally` ブロック内のファイル削除ロジックが必ず実行されるようにすることである。
```

---

## 領域8: 開発プロセスと検証 (Development Process & Validation)

### ルール 8.1: 盲目的に信頼するのではなく、仮説を積極的に検証しなければならない。

**目的**: エラーが発生する前にそれを捕捉し、コードの堅牢性を高めるため。

**誤った例**:
```
ある関数がパラメータ `items` を受け取り、コードはそれが配列であると即座に仮定して
`items.map()` を呼び出す。
渡された `items` が `null` または `undefined` の場合、プログラムは即座にクラッシュする。
```

**正しい例**:
```
`.map()` を呼び出す前に、まず `items` が真値であり、かつ配列であるかを確認する。
そうでない場合は、空の配列を早期に返すか、エラー処理を適切に行う。
```

### ルール 8.2: エッジケースを考慮し、テストしなければならない。

**目的**: 非典型的、極端、または誤った入力に対してもコードが正常に機能することを保証するため。

**誤った例**:
```
リストのソート機能を開発する際、5つの正常な項目を含む配列のみでテストした。
空の配列、1つの項目のみを含む配列、または `null` 値を含む配列ではテストしなかった。
```

**正しい例**:
```
開発とテストの際には、様々なエッジケースを積極的に入力として使用する：
- ヌル値 (`null`, `undefined`)
- 空のコレクション（空文字列、空配列）
- 単一要素のコレクション
- 不正なフォーマットや極端な値を含むコレクション
```

### ルール 8.3: Webアプリケーションのデバッグには、自動化されたブラウザ制御を使用し、結果を積極的に報告しなければならない。

**目的**: フロントエンドのバグを自動的に再現し、ランタイムエラーを捕捉し、具体的な診断レポートを提供することで、「ユーザーに手動でコンソールを確認させる」という非効率な手法を置き換えるため。

**誤った例**:
```
「ウェブサイトのボタンをクリックしても反応がない」と報告されたとき、AIは次のように返信する：
「コードのロジックは問題ないようです。ブラウザの開発者ツールを開き、
ボタンをクリックした後、コンソールタブにエラーが表示されていないか確認して、エラーメッセージを教えてください。」
—— このアプローチは、デバッグの責任をユーザーに押し付けている。
```

**正しい例**:
```
フロントエンドのバグ報告を受けた際、AIは以下の自動化プロセスを積極的に開始すべきである：

1.  **ツールの起動**:
    Puppeteerのようなヘッドレスブラウザツールを使用してユーザー操作をシミュレートすることを表明する。

2.  **環境設定**:
    スクリプト内でリスナーを設定し、以下を捕捉する：
    - `console` イベント（`console.log`、`console.error` など）
    - `pageerror` イベント（キャッチされなかったJavaScriptランタイムエラー）
    - `requestfailed` イベント（404やCORSエラーなど、すべての失敗したネットワークリクエスト）

3.  **操作のシミュレーション**:
    プログラムで指定されたページに移動し、バグをトリガーする操作（ボタンのクリック、フォームの入力など）を実行する。

4.  **分析と報告**:
    捕捉したすべてのエラーとログを収集し、それを明確なレポートにまとめてユーザーに直接提示する。

    レポートには以下を含むべきである：
    - 実行したステップ
    - 捕捉したエラーメッセージ
    - エラーが発生したソースコードの場所
    - 原因の一次分析

    例：
    「自動デバッグレポート：
    `#login-button` をクリックした後、`pageerror` イベントが捕捉されました。
    エラーは `TypeError: Cannot read properties of undefined (reading 'value')` で、
    `login.js` の52行目で発生しました。
    一次分析として、ログインスクリプトが存在しないDOM要素の値を読み取ろうとしている可能性があります。」
```

---

## まとめ

これらのルールは、AI支援開発における中核的なセーフティネットを構成します。これらのルールに従うことで、一般的なエラーを大幅に削減し、コードの品質を向上させ、開発速度を加速させることができます。覚えておいてください：**仮説より分析を、信頼より検証を**。
